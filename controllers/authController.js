import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import * as usersModel from '../models/usersModel.js'
import * as profilesModel from '../models/profilesModel.js';
import convertUserToSend from '../utills/convertUser.js';
import emailValidator from 'email-validator';

const accessTokenExpireTime = '1200s'
const refreshTokenExpireTime = '365d'

const validateEmailAndPassword = (email, password, res) => {
    if (!email || !password) {
        res.status(400).json({ message: 'email and password fields are required' });
        return false;
    } if (!emailValidator.validate(email)) {
        res.status(400).json({ message: 'The email is incorrect' });
        return false;
    } if (password.length < 6) {
        res.status(400).json({ message: 'The password length must be at least 6' });
        return false;
    }
    return true;
}

export const createNewUser = async (req, res) => {
    const email = req.body.email?.trim();
    const password = req.body.password?.trim();

    // validations
    const isValid = validateEmailAndPassword(email, password, res);
    if (!isValid) return;

    // check duplicates
    if (await usersModel.haveDuplicateWithEmail(email)) {
        return res.status(409).json({ message: `User with email ${email} is alredy exists` });
    }

    // create user
    const hashedPassword = await bcrypt.hash(password, 10);
    const userId = await usersModel.createUser(email, hashedPassword);
    await profilesModel.createUserProfile(userId);

    return res.status(201).json({ success: `New user with email ${email} created` });
}

export const login = async (req, res) => {
    const email = req.body.email?.trim();
    const password = req.body.password?.trim();

    // validations
    const isValid = validateEmailAndPassword(email, password, res);
    if (!isValid) return;

    // get user
    const foundUser = await usersModel.getUserByEmail(email);
    if (!foundUser) {
        return res.status(404).json({ message: `User with email ${email} not found` });
    }

    // login
    const match = await bcrypt.compare(password, foundUser.password);
    if (match) {
        const accessToken = jwt.sign(
            {
                "UserInfo": {
                    "id": foundUser.id,
                }
            },
            process.env.ACCESS_TOKEN_SECRET,
            { expiresIn: accessTokenExpireTime }
        );
        const refreshToken = jwt.sign(
            {
                "UserInfo": {
                    "id": foundUser.id,
                }
            },
            process.env.REFRESH_TOKEN_SECRET,
            { expiresIn: refreshTokenExpireTime }
        );

        await usersModel.addRefreshToken(foundUser.id, refreshToken);

        return res.status(200).json({ data: { accessToken: accessToken, refreshToken: refreshToken, user: convertUserToSend(foundUser, { userId: foundUser.id }) } });
    } else {
        return res.status(401).json({ message: 'Password is incorrect' });
    }
}

export const refreshToken = async (req, res) => {
    const refreshToken = req.body.refreshToken?.trim();

    // validations
    if (!refreshToken) return res.sendStatus(401);

    // get user
    const foundUser = await usersModel.getUserByRefreshToken(refreshToken);
    if (!foundUser) {
        jwt.verify(
            refreshToken,
            process.env.REFRESH_TOKEN_SECRET,
            async (err, decoded) => {
                if (err) return;
                const hackedUser = await usersModel.getUserById(decoded.UserInfo.id);
                if (!hackedUser) return;
                await usersModel.resetRefreshTokensByUserId(hackedUser.id);
            });
        return res.sendStatus(404);
    }

    // verify and refresh
    jwt.verify(
        refreshToken,
        process.env.REFRESH_TOKEN_SECRET,
        async (err, decoded) => {
            if (err || foundUser.id !== decoded.UserInfo.id) return res.sendStatus(403);
            const newAccessToken = jwt.sign(
                {
                    "UserInfo": {
                        "id": decoded.UserInfo.id,
                    }
                },
                process.env.ACCESS_TOKEN_SECRET,
                { expiresIn: accessTokenExpireTime }
            );
            // refreshToken is not needed now
            // const newRefreshToken = jwt.sign(
            //     {
            //         "UserInfo": {
            //             "id": decoded.UserInfo.id,
            //         }
            //     },
            //     process.env.REFRESH_TOKEN_SECRET,
            //     { expiresIn: refreshTokenExpireTime }
            // );

            // const newRefreshTokens = [foundUser.refresh_tokens.filter(token => token !== refreshToken), newRefreshToken];
            // await usersModel.updateRefreshTokens(foundUser.id, newRefreshTokens);

            return res.status(200).json({ accessToken: newAccessToken });
        }
    );
}

export const logout = async (req, res) => {
    const refreshToken = req.body.refreshToken?.trim();

    // validations
    if (!refreshToken) return res.sendStatus(401);

    // get user
    const foundUser = await usersModel.getUserByRefreshToken(refreshToken);
    if (!foundUser) {
        return res.sendStatus(204);
    }

    // delete token
    await usersModel.delteRefreshToken(refreshToken);

    return res.sendStatus(204);
}